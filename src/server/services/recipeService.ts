import { gemini } from '../config/gemini';
import { RecipeSuggestion, RecipeGenerationParams } from '../types/recipe.types';
import { Product } from '../models/Product';
import { RecipeValidationError, GeminiApiError } from '../errors/recipeErrors';
import { RecipeSuggestionSchema } from '../types/recipe.schemas';
import { z } from 'zod';

export class RecipeService {
  /**
   * Generates a recipe based on the provided parameters.
   * The recipe is generated by a Gemini AI model that is given a prompt based on the parameters.
   * The prompt includes the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * The AI model is expected to generate a valid JSON with the RecipeSuggestion structure.
   * @param params The parameters for generating the recipe, including the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * @returns A promise that resolves to a valid RecipeSuggestion object.
   * @throws Error - If the AI model fails to generate a valid recipe, or if the generated recipe is missing a required field or does not include at least one ingredient and one step.
   */
  public static async generateRecipe(params: RecipeGenerationParams): Promise<RecipeSuggestion> {
    const { preferred: preferredProducts, available: availableProducts } = await this.getFilteredProducts(params);
    const prompt = this.buildPrompt(params, preferredProducts, availableProducts);
    let rawApiResponseText: string | undefined;

    try {
      const systemPrompt =
        'You are a nutrition expert chef who creates healthy and delicious recipes based on Mercadona products. Your response MUST be a valid JSON with the RecipeSuggestion structure. Respond ONLY with the JSON object, without any introductory text or markdown formatting.'; // Prompt mejorado

      const chat = gemini.recipeModel.startChat({
        history: [
          { role: 'user', parts: [{ text: systemPrompt }] },
          {
            role: 'model',
            parts: [{ text: 'Understood, I am ready to generate recipes in JSON format.' }],
          },
        ],
      });

      console.log('Sending prompt to Gemini...');
      const result = await chat.sendMessage(prompt);
      const response = result.response;
      rawApiResponseText = response.text();
      console.log('Received raw response from Gemini.');

      let jsonString = rawApiResponseText;
      let rawRecipeObject: any;

      try {
        rawRecipeObject = JSON.parse(jsonString);
        console.log('Successfully parsed JSON directly.');
      } catch (e1) {
        console.warn('Direct JSON parsing failed, attempting extraction...');
        try {
          const firstBrace = jsonString.indexOf('{');
          const lastBrace = jsonString.lastIndexOf('}');
          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
            jsonString = jsonString.substring(firstBrace, lastBrace + 1);
            rawRecipeObject = JSON.parse(jsonString);
            console.log('Successfully parsed JSON extracted between {} braces.');
          } else {
            throw new Error('No JSON object found between braces');
          }
        } catch (e2) {
          console.warn('JSON extraction between braces failed, attempting regex...');
          const jsonMatch =
            rawApiResponseText.match(/```json\n([\s\S]*?)\n```/) ||
            rawApiResponseText.match(/```([\s\S]*?)```/) ||
            rawApiResponseText.match(/\{[\s\S]*\}/);
          jsonString = jsonMatch
            ? jsonMatch[0].replace(/```json\n?/, '').replace(/```$/, '')
            : rawApiResponseText;
          try {
            rawRecipeObject = JSON.parse(jsonString);
            console.log('Successfully parsed JSON extracted via regex.');
          } catch (parseError) {
            console.error('Failed to parse JSON even after extraction attempts:', parseError);
            console.error('Original raw text:', rawApiResponseText);
            console.error('Attempted JSON string:', jsonString);
            throw new RecipeValidationError(
              'The recipe format received was invalid (not valid JSON).'
            );
          }
        }
      }

      try {
        console.log('Validating recipe structure with Zod...');
        const validatedRecipe = RecipeSuggestionSchema.parse(rawRecipeObject);
        console.log('Recipe validation successful.');

        return validatedRecipe as RecipeSuggestion;
      } catch (validationError) {
        if (validationError instanceof z.ZodError) {
          console.error('Recipe validation failed:', validationError.issues);
          const errorMessages = validationError.issues
            .map(e => `${e.path.join('.')} : ${e.message}`)
            .join('; ');
          throw new RecipeValidationError(
            `Invalid recipe structure received from AI: ${errorMessages}`
          );
        }
        console.error('Unexpected error during Zod validation:', validationError);
        throw validationError;
      }
    } catch (error) {
      console.error('Error in generateRecipe main process:', error);

      if (error instanceof RecipeValidationError || error instanceof GeminiApiError) {
        throw error;
      } else {
        throw new GeminiApiError(
          `Failed to generate recipe. Service issue: ${error instanceof Error ? error.message : 'Unknown API error'}`,
          rawApiResponseText
        );
      }
    }
  }

  /**
   * Gets a list of products filtered by the nutritional goals specified in the parameters.
   * The products are filtered by the maximum calories, minimum protein, maximum carbohydrates, and maximum fat.
   * @param params The parameters for generating the recipe, including the nutritional goals.
   * @returns A promise that resolves to a list of products filtered by the nutritional goals.
   */
  private static async getFilteredProducts(
    params: RecipeGenerationParams
  ): Promise<{ preferred: any[]; available: any[] }> {
    const { nutritionalGoals, preferences } = params;
    const preferredIngredients = preferences.preferredIngredients || [];
    const preferredProducts: any[] = [];
    const availableProducts: any[] = [];
    const limit = 100; // Límite total de productos para el prompt
    const fetchedIds = new Set<string>(); // Para evitar duplicados

    console.log(
      `Filtering products. Preferred: [${preferredIngredients.join(', ')}]. Nutritional Goals:`,
      nutritionalGoals
    );

    // 1. Buscar productos preferidos que cumplan requisitos nutricionales
    if (preferredIngredients.length > 0) {
      const preferredQuery: any = {
        name: { $in: preferredIngredients.map(ing => new RegExp(ing.trim(), 'i')) }, // trim() añadido
      };
      // Aplicar filtros nutricionales TAMBIÉN a los preferidos
      if (nutritionalGoals.maxCalories)
        preferredQuery['nutritionalInfo.calories'] = { $lte: nutritionalGoals.maxCalories };
      if (nutritionalGoals.minProtein)
        preferredQuery['nutritionalInfo.protein'] = { $gte: nutritionalGoals.minProtein };
      if (nutritionalGoals.maxCarbs)
        preferredQuery['nutritionalInfo.carbs'] = { $lte: nutritionalGoals.maxCarbs };
      if (nutritionalGoals.maxFat)
        preferredQuery['nutritionalInfo.fat'] = { $lte: nutritionalGoals.maxFat };
      if (nutritionalGoals.minCalories)
        preferredQuery['nutritionalInfo.calories'] = {
          ...(preferredQuery['nutritionalInfo.calories'] || {}),
          $gte: nutritionalGoals.minCalories,
        }; // Añadido minCalories

      try {
        const foundPreferred = await Product.find(preferredQuery)
          .limit(preferredIngredients.length * 2) // Un límite razonable
          .lean();
        foundPreferred.forEach(p => {
          if (!fetchedIds.has(p._id.toString())) {
            preferredProducts.push(p);
            fetchedIds.add(p._id.toString());
          }
        });
        console.log(`Found ${preferredProducts.length} preferred products matching criteria.`);
      } catch (dbError) {
        console.error('Error fetching preferred products:', dbError);
        // Continuar sin preferidos si hay error de DB
      }
    }

    // 2. Buscar otros productos disponibles
    const remainingLimit = Math.max(0, limit - preferredProducts.length);
    if (remainingLimit > 0) {
      const availableQuery: any = {
        _id: { $nin: Array.from(fetchedIds) }, // Excluir los ya encontrados
      };
      // Aplicar filtros nutricionales a los disponibles
      if (nutritionalGoals.maxCalories)
        availableQuery['nutritionalInfo.calories'] = { $lte: nutritionalGoals.maxCalories };
      if (nutritionalGoals.minProtein)
        availableQuery['nutritionalInfo.protein'] = { $gte: nutritionalGoals.minProtein };
      if (nutritionalGoals.maxCarbs)
        availableQuery['nutritionalInfo.carbs'] = { $lte: nutritionalGoals.maxCarbs };
      if (nutritionalGoals.maxFat)
        availableQuery['nutritionalInfo.fat'] = { $lte: nutritionalGoals.maxFat };
      if (nutritionalGoals.minCalories)
        availableQuery['nutritionalInfo.calories'] = {
          ...(availableQuery['nutritionalInfo.calories'] || {}),
          $gte: nutritionalGoals.minCalories,
        }; // Añadido minCalories

      try {
        const foundAvailable = await Product.find(availableQuery)
          // .sort({ /* Podrías añadir un sort si quieres, p.ej., por popularidad si tuvieras ese dato */ })
          .limit(remainingLimit)
          .lean();
        availableProducts.push(...foundAvailable);
        console.log(`Found ${availableProducts.length} additional available products.`);
      } catch (dbError) {
        console.error('Error fetching available products:', dbError);
        // Continuar sin disponibles si hay error de DB
      }
    } else {
      console.log('Limit reached with preferred products.');
    }

    return { preferred: preferredProducts, available: availableProducts };
  }

  /**
   * Builds a prompt for the recipe generation model based on the given parameters and available products.
   * The prompt includes dietary requirements, nutritional objectives, available products, and specific instructions.
   * @param params The parameters for generating the recipe, including the dietary preferences and nutritional objectives.
   * @param products The available products that can be used for generating the recipe.
   * @returns A string containing the prompt for the recipe generation model.
   */
  private static buildPrompt(params: RecipeGenerationParams, preferredProducts: any[], availableProducts: any[]): string {
    const { preferences, nutritionalGoals } = params;

    const dietInstructions: Record<string, string> = {
      vegan: 'The recipe should be 100% vegan (without animal or processed products).',
      vegetarian:
        'The recipe should be vegetarian (can include dairy and eggs, but no meat or fish).',
      'gluten-free':
        'The recipe should be gluten-free. Avoid wheat, barley, oats, and their derivatives.',
      'lactose-free':
        'The recipe should not contain lactose. Avoid milk and dairy products that contain lactose.',
      keto: 'The recipe should be ketogenic (low in carbohydrates, high in healthy fats).',
      'low-carb': 'The recipe should be low in carbohydrates.',
      'high-protein': 'The recipe should be rich in protein.',
      'high-fiber': 'The recipe should be rich in fiber.',
    };

    const dietInstruction = dietInstructions[preferences.diet] || '';

    const includedProductsList =
      preferredProducts.length > 0
        ? preferredProducts.map(p => `- ${p.name}${p.brand ? ` (${p.brand})` : ''}`).join('\n')
        : 'None specifically requested or found matching criteria.'; // Mensaje más claro

    const availableProductsList =
      availableProducts.length > 0
        ? availableProducts.map(p => `- ${p.name}${p.brand ? ` (${p.brand})` : ''}`).join('\n')
        : 'None available based on criteria.'; // Mensaje más claro

    // Construir el prompt
    // (Usa el mismo template que tenías, pero ahora las listas vienen pre-calculadas)
    return `
  Generate a recipe in Spanish with the following characteristics:

  DIETARY REQUIREMENTS:
  ${dietInstruction}
  - Ingredients to avoid: ${preferences.excludedIngredients?.join(', ') || 'None in particular'}
  - Cooking time: ${preferences.cookingTime || 'Not specified'} minutes
  - Difficulty: ${preferences.difficulty || 'Not specified'}

  NUTRITIONAL OBJECTIVES PER PORTION:
  ${nutritionalGoals.minCalories ? `- Minimum calories: ${nutritionalGoals.minCalories}` : ''}
  ${nutritionalGoals.maxCalories ? `- Maximum calories: ${nutritionalGoals.maxCalories}` : ''}
  ${nutritionalGoals.minProtein ? `- Minimum of proteins: ${nutritionalGoals.minProtein}g` : ''}
  ${nutritionalGoals.maxCarbs ? `- Maximum of carbohydrates: ${nutritionalGoals.maxCarbs}g` : ''}
  ${nutritionalGoals.maxFat ? `- Maximum of fats: ${nutritionalGoals.maxFat}g` : ''}

  INGREDIENTS TO INCLUDE (MUST attempt to use these):
  ${includedProductsList}

  OTHER AVAILABLE PRODUCTS (use these to complete the recipe if needed):
  ${availableProductsList}

  CALORIE REQUIREMENTS (VERY IMPORTANT):
  - The recipe's nutritional info per portion MUST meet:
    ${nutritionalGoals.minCalories ? `  - AT LEAST ${nutritionalGoals.minCalories} calories.\n` : ''}
    ${nutritionalGoals.maxCalories ? `  - NO MORE THAN ${nutritionalGoals.maxCalories} calories.\n` : ''}
  - If the initial ingredient list does not meet the calorie requirements, you MUST adjust quantities or add/remove ingredients (from the available list or common pantry staples compatible with the diet) to meet the target.
  - Prioritize meeting the minimum calorie requirement if both min and max are set.
  - The final "nutritionalInfo.calories" field in your JSON response MUST strictly adhere to these requirements.

  SPECIFIC INSTRUCTIONS:
  1. Use ingredients from the 'INGREDIENTS TO INCLUDE' list preferentially.
  2. Supplement with 'OTHER AVAILABLE PRODUCTS' or common compatible pantry items (like oil, spices, basic vegetables) as needed to create a complete and balanced recipe.
  3. Specify EXACT quantities for each ingredient (e.g., in grams, ml, units). Avoid vague amounts.
  4. Ensure the final recipe is strictly compatible with the diet: ${preferences.diet}. If unsure about an ingredient, do not include it.
  5. Provide clear, step-by-step preparation instructions in Spanish.
  6. Calculate the nutritional information per serving ACCURATELY based on the chosen ingredients and quantities. Double-check calorie compliance before responding.

  RESPONSE FORMAT (JSON ONLY - NO extra text or markdown):
  {
    "name": "Recipe name (in Spanish)",
    "description": "Short recipe description (in Spanish)",
    "preparationTime": 30, // in minutes
    "servings": 2,
    "difficulty": "easy", // "easy", "medium", or "hard"
    "ingredients": [
      { "name": "ingredient name", "quantity": 100, "unit": "g" } // Example format
    ],
    "steps": ["Paso 1...", "Paso 2..."], // In Spanish
    "nutritionalInfo": {
      "calories": 500, // MUST meet calorie requirements
      "protein": 30,
      "carbs": 50,
      "fat": 20,
      "sugar": 10,       // Optional but preferred
      "saturatedFat": 5, // Optional but preferred
      "sodium": 800,     // Optional but preferred
      "fiber": 8         // Optional but preferred
    },
    "dietaryTags": ["${preferences.diet}"] // Include the requested diet
  }
  `;
  }

}
