import { RecipeSuggestion, RecipeGenerationParams } from '../types/recipe.types';
import { Product } from '../models/Product';
import {
  createGeminiChat,
  extractJsonResponse,
  validateNutritionalRequirements,
  handleGenerationError,
} from './recipeGeneration';
import { RecipeSuggestionSchema } from '../types/recipe.schemas';
import { RecipeValidationError } from '../errors/recipeErrors';
import { z } from 'zod';

export class RecipeService {
  /**
   * Generates a recipe based on the provided parameters.
   * The recipe is generated by a Gemini AI model that is given a prompt based on the parameters.
   * The prompt includes the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * The AI model is expected to generate a valid JSON with the RecipeSuggestion structure.
   * @param params The parameters for generating the recipe, including the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * @returns A promise that resolves to a valid RecipeSuggestion object.
   * @throws Error - If the AI model fails to generate a valid recipe, or if the generated recipe is missing a required field or does not include at least one ingredient and one step.
   */
  public static async generateRecipe(params: RecipeGenerationParams): Promise<RecipeSuggestion> {
    const limit = 100;
    const ingredientThemes = params.preferences.ingredientThemes;
    const query = {};
    const products = await this.fetchProducts(query, limit);

    const prompt = this.buildPrompt(params, products, ingredientThemes);
    let rawApiResponseText: string | undefined;

    try {
      // Initialize chat and send prompt
      const chat = createGeminiChat();
      console.log('Sending prompt to Gemini...');

      const result = await chat.sendMessage(prompt);
      rawApiResponseText = result.response.text();
      console.log('Received response from Gemini.');

      // Parse and validate the response
      const rawRecipeObject = extractJsonResponse(rawApiResponseText);
      const validatedRecipe = RecipeSuggestionSchema.parse(rawRecipeObject);

      // Validate nutritional requirements
      validateNutritionalRequirements(
        validatedRecipe,
        products,
        params
      );

      return validatedRecipe;
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error('Recipe validation failed:', error.issues);
        const errorMessages = error.issues
          .map(e => `${e.path.join('.')} : ${e.message}`)
          .join('; ');
        throw new RecipeValidationError(
          `Invalid recipe structure received from AI: ${errorMessages}`
        );
      }
      return handleGenerationError(error, rawApiResponseText);
    }
  }

  /**
   * Fetches products from the database based on the provided query
   * @param query The MongoDB query object
   * @param limit Maximum number of products to return
   * @param excludeIds Array of product IDs to exclude
   * @returns An array of products
   */
  private static async fetchProducts(
    query: Record<string, unknown>,
    limit: number
  ): Promise<any[]> {
    try {
      const products = await Product.find(query).limit(limit).lean();
      return products;
    } catch (error) {
      console.error('Error fetching products:', error);
      return [];
    }
  }

  private static buildPrompt(
    params: RecipeGenerationParams,
    products: any[],
    ingredientThemes: string[]
  ): string {
    const { preferences, nutritionalGoals } = params;

    const formatProducts = (products: any[]) =>
      products
        .map(
          p =>
            `- ${p.name}${p.brand ? ` (${p.brand})` : ''} | ` +
            `Calories: ${p.nutritionalInfo?.calories || 'N/A'} | ` +
            `Protein: ${p.nutritionalInfo?.protein || 'N/A'}g | ` +
            `Carbs: ${p.nutritionalInfo?.carbs || 'N/A'}g | ` +
            `Fat: ${p.nutritionalInfo?.fat || 'N/A'}g`
        )
        .join('\n');

    const formattedProducts = formatProducts(products);

    const dietRequirements = {
      vegan: 'Must be 100% plant-based, no animal products including honey, dairy, or eggs.',
      vegetarian: 'May include dairy and eggs but no meat, poultry, or fish.',
      keto: 'Must be very low in carbs (under 10g net carbs per serving).',
      'gluten-free': 'Must not contain wheat, barley, rye, or any gluten sources.',
      'lactose-free': 'Must not contain lactose or dairy products.',
      'high-protein': 'Must contain at least 25g of protein per serving.',
      'low-carb': 'Must contain less than 30g of net carbs per serving.',
      'high-fiber': 'Must contain at least 8g of fiber per serving.',
      omnivore: 'May include all food groups including meat, dairy, and plant-based ingredients.',
    };

    const dietInstruction =
      dietRequirements[preferences.diet] || 'No specific dietary restrictions.';

    return `
## RECIPE GENERATION INSTRUCTIONS

Your task is to generate a recipe in SPANISH that STRICTLY meets all the requirements.

### DIETARY PREFERENCES
- **Diet type**: ${params.preferences.diet} (${dietInstruction})
- **Ingredients to avoid**: ${params.preferences.excludedIngredients.join(', ') || 'None'}
- **Cooking time**: ${params.preferences.cookingTime ? `${params.preferences.cookingTime} minutes` : 'Not specified'}
- **Difficulty**: ${params.preferences.difficulty || 'Any'}

### NUTRITIONAL GOALS (Per serving)
${params.nutritionalGoals.minCalories ? `- Minimum calories: ${params.nutritionalGoals.minCalories}\n` : 'No minimum calories specified'}
${params.nutritionalGoals.maxCalories ? `- Maximum calories: ${params.nutritionalGoals.maxCalories}\n` : 'No maximum calories specified'}
${params.nutritionalGoals.minProtein ? `- Minimum protein: ${params.nutritionalGoals.minProtein}g\n` : 'No minimum protein specified'}
${params.nutritionalGoals.maxCarbs ? `- Maximum carbs: ${params.nutritionalGoals.maxCarbs}g\n` : 'No maximum carbs specified'}
${params.nutritionalGoals.maxFat ? `- Maximum fat: ${params.nutritionalGoals.maxFat}g` : 'No maximum fat specified'}

${
  ingredientThemes.length > 0
    ? `### MANDATORY INGREDIENT THEMES
The recipe MUST include at least one product from the "AVAILABLE" list that matches each of the following themes:
${ingredientThemes.map(theme => `- ${theme}`).join('\n')}
\n`
    : ''
}

### AVAILABLE INGREDIENT DATABASE
Here are the ingredients from the database you can use to build the recipe:
${
  formattedProducts.length > 0
    ? formattedProducts
    : 'No specific products available. Use common ingredients.'
}
\n
${
  formattedProducts.length === 0 && ingredientThemes.length > 0
    ? '#### WARNING\nNo products found in the database. Generate a generic recipe using common ingredients that match the mandatory themes.\n'
    : ''
}

### REQUIRED RESPONSE FORMAT (VALID JSON)
\`\`\`json
{
  "name": "string",
  "description": "string",
  "preparationTime": number,
  "servings": number,
  "difficulty": "easy" | "medium" | "hard",
  "ingredients": [
    {
      "name": "string",
      "quantity": number,
      "unit": "string"
    }
  ],
  "steps": ["string"],
  "nutritionalInfo": {
    "calories": number,
    "protein": number,
    "carbs": number,
    "fat": number,
    "sugar": number,
    "saturatedFat": number,
    "sodium": number,
    "fiber": number
  },
  "dietaryTags": ["string"]
}
\`\`\`

### STRICT RULES (MUST BE FOLLOWED)
1.  **VALID JSON**: The response MUST be a single JSON code block. Do not include any text before or after.
2.  **INGREDIENTS**:
    - You MUST base the recipe on ingredients from the "AVAILABLE INGREDIENT DATABASE".
     - You MUST satisfy all "MANDATORY INGREDIENT THEMES" by selecting at least one matching product from the list for each theme.
    - All quantities and units are required.
3.  **NUTRITION**:
    - The generated nutritional information (calories, protein, etc.) MUST be a realistic calculation based on the provided ingredients and their quantities.
    - It MUST meet the defined NUTRITIONAL GOALS.
4.  **DIFFICULTY**: Must be "easy", "medium", or "hard".
5.  **LANGUAGE**: Everything in English and in lowercase (except proper nouns if necessary).
6.  **UNITS**: All ingredient "unit" fields MUST be expressed in "g" (grams) or "kg" (kilograms). Do NOT use "units", "ml", "tbsp", "tsp", or any other measure.

### VALID EXAMPLE:
\`\`\`json
{
  "name": "quinoa salad with chicken breast",
  "description": "Fresh salad using quinoa and chicken breast from the list.",
  "preparationTime": 25,
  "servings": 2,
  "difficulty": "easy",
  "ingredients": [
    {"name": "quinoa (Hacendado)", "quantity": 100, "unit": "g"},
    {"name": "chicken breast (PolloFeliz)", "quantity": 150, "unit": "g"},
    {"name": "tomato", "quantity": 1, "unit": "unit"},
    {"name": "olive oil", "quantity": 1, "unit": "tablespoon"}
  ],
  "steps": ["Cook the quinoa", "Chop the vegetables", "Cook the chicken"],
  "nutritionalInfo": {
    "calories": 450,
    "protein": 30,
    "carbs": 40,
    "fat": 20,
    "fiber": 6
  },
  "dietaryTags": ["high protein", "gluten free"]
}
\`\`\`

### FINAL INSTRUCTIONS
Generate the recipe. Remember: your response must be ONLY the JSON block, and it must follow ALL the rules, especially using ingredients from the lists and meeting the nutritional goals.
  `;
  }
}
