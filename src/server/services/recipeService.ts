import { gemini } from '../config/gemini';
import {
  RecipeSuggestion,
  RecipeGenerationParams,
} from '../types/recipe.types';
import { Product } from '../models/Product';

export class RecipeService {
  
  /**
   * Generates a healthy and delicious recipe based on the given parameters and available Mercadona products.
   * The recipe is generated by calling the OpenAI API with a prompt that includes the dietary requirements, nutritional objectives, available products, and specific instructions.
   * The response is then parsed and validated to ensure it meets the required recipe structure.
   * @param params The parameters for generating the recipe, including the dietary preferences and nutritional objectives.
   * @returns A promise that resolves to a RecipeSuggestion object containing the generated recipe.
   * @throws Error If the recipe could not be generated or if the response from the OpenAI API is invalid.
   */
  public static async generateRecipe(params: RecipeGenerationParams): Promise<RecipeSuggestion> {
    const products = await this.getFilteredProducts(params);
    const prompt = this.buildPrompt(params, products);

    try {
      const systemPrompt = 'Eres un chef experto en nutrición que crea recetas saludables y deliciosas basadas en productos de Mercadona. Tu respuesta DEBE ser un JSON válido con la estructura de RecipeSuggestion.';
      
      const chat = gemini.recipeModel.startChat({
        history: [
          {
            role: 'user',
            parts: [{ text: systemPrompt }],
          },
          {
            role: 'model',
            parts: [{ text: 'Entendido, estoy listo para generar recetas en formato JSON.' }],
          },
        ],
      });

      const result = await chat.sendMessage(prompt);
      const response = await result.response;
      const text = response.text();
      
      // Limpiar la respuesta para extraer solo el JSON
      const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/) || text.match(/```([\s\S]*?)```/);
      const jsonString = jsonMatch ? jsonMatch[1] || jsonMatch[0] : text;
      
      const recipe = JSON.parse(jsonString) as RecipeSuggestion;
      this.validateRecipe(recipe);

      return recipe;
    } catch (error) {
      console.error('Error generating recipe:', error);
      throw new Error('Error generating the recipe. Please try again.');
    }
  }

  /**
   * Gets a list of products filtered by the nutritional goals specified in the parameters.
   * The products are filtered by the maximum calories, minimum protein, maximum carbohydrates, and maximum fat.
   * A maximum of 100 products are returned.
   * @param params The parameters for generating the recipe, including the nutritional goals.
   * @returns A promise that resolves to a list of products filtered by the nutritional goals.
   */
  private static async getFilteredProducts(params: RecipeGenerationParams) {
    const { nutritionalGoals } = params;
    const query: any = {};

    if (nutritionalGoals.maxCalories) {
      query['nutritionalInfo.calories'] = { $lte: nutritionalGoals.maxCalories };
    }
    if (nutritionalGoals.minProtein) {
      query['nutritionalInfo.protein'] = { $gte: nutritionalGoals.minProtein };
    }
    if (nutritionalGoals.maxCarbs) {
      query['nutritionalInfo.carbs'] = { $lte: nutritionalGoals.maxCarbs };
    }
    if (nutritionalGoals.maxFat) {
      query['nutritionalInfo.fat'] = { $lte: nutritionalGoals.maxFat };
    }

    return Product.find(query).limit(100).lean();
  }

  /**
   * Builds a prompt for the recipe generation model based on the given parameters and available products.
   * The prompt includes dietary requirements, nutritional objectives, available products, and specific instructions.
   * @param params The parameters for generating the recipe, including the dietary preferences and nutritional objectives.
   * @param products The available products that can be used for generating the recipe.
   * @returns A string containing the prompt for the recipe generation model.
   */
  private static buildPrompt(params: RecipeGenerationParams, products: any[]): string {
    const { preferences, nutritionalGoals } = params;

    const dietInstructions: Record<string, string> = {
      'vegan': 'The recipe should be 100% vegan (without animal or processed products).',
      'vegetarian': 'The recipe should be vegetarian (can include dairy and eggs, but no meat or fish).',
      'gluten-free': 'The recipe should be gluten-free. Avoid wheat, barley, oats, and their derivatives.',
      'lactose-free': 'The recipe should not contain lactose. Avoid milk and dairy products that contain lactose.',
      'keto': 'The recipe should be ketogenic (low in carbohydrates, high in healthy fats).',
      'low-carb': 'The recipe should be low in carbohydrates.',
      'high-protein': 'The recipe should be rich in protein.',
      'high-fiber': 'The recipe should be rich in fiber.',
    };

    const dietInstruction = dietInstructions[preferences.diet] || '';

    const productList = products
      .slice(0, 100) 
      .map(p => `- ${p.name}${p.brand ? ` (${p.brand})` : ''}`)
      .join('\n');

    return `
  Generate a recipe with the following characteristics:
  
  DIETARY REQUIREMENTS:
  ${dietInstruction}
  - Ingredients to avoid: ${preferences.excludedIngredients.join(', ') || 'None in particular'}
  - Cooking time: ${preferences.cookingTime || 'Not specified'} minutes
  - Difficulty: ${preferences.difficulty || 'Not specified'}
  
  NUTRITIONAL OBJECTIVES PER PORTION:
  ${nutritionalGoals.maxCalories ? `- Maximum calories: ${nutritionalGoals.maxCalories}` : ''}
  ${nutritionalGoals.minProtein ? `- Minimum of proteins: ${nutritionalGoals.minProtein}g` : ''}
  ${nutritionalGoals.maxCarbs ? `- Maximum of carbohydrates: ${nutritionalGoals.maxCarbs}g` : ''}
  ${nutritionalGoals.maxFat ? `- Maximum of fats: ${nutritionalGoals.maxFat}g` : ''}
  
  AVAILABLE PRODUCTS (you can use these or similar ones):
  ${productList}
  
  SPECIFIC INSTRUCTIONS:
  - Only include ingredients that are compatible with the diet ${preferences.diet}.
  - If you are not sure if an ingredient is compatible with the diet, do not include it.
  - The recipe should be balanced and healthy.
  - Include specific quantities for each ingredient.
  - Provide clear preparation instructions in steps.
  
  RESPONSE FORMAT (JSON):
  {
    "name": "Recipe name",
    "description": "Short recipe description",
    "preparationTime": 30,
    "servings": 2,
    "difficulty": "easy",
    "ingredients": [
      {
        "name": "ingredient name",
        "quantity": 1,
        "unit": "unit"
      }
    ],
    "steps": ["Step 1", "Step 2"],
    "nutritionalInfo": {
      "calories": 500,
      "protein": 30,
      "carbs": 50,
      "fat": 20
    },
    "dietaryTags": ["${preferences.diet}"]
  }
  
  IMPORTANT: Make sure that the recipe is strictly compatible with the diet ${preferences.diet}.
  `;
  }

 
  /**
   * Validates a generated recipe by checking that it includes all the required fields
   * and at least one ingredient and one step.
   *
   * @param recipe - The generated recipe to validate
   *
   * @throws Error - If the recipe is missing a required field or does not include at least one ingredient and one step.
   */
  private static validateRecipe(recipe: RecipeSuggestion): void {
    const requiredFields = [
      'name',
      'description',
      'preparationTime',
      'servings',
      'difficulty',
      'ingredients',
      'steps',
      'nutritionalInfo',
      'dietaryTags',
    ];

    for (const field of requiredFields) {
      if (!(field in recipe)) {
        throw new Error(`The generated recipe is missing required field: ${field}`);
      }
    }

    // Validate that there is at least one ingredient and one step
    if (recipe.ingredients.length === 0) {
      throw new Error('The recipe must include at least one ingredient');
    }

    if (recipe.steps.length === 0) {
      throw new Error('The recipe must include at least one preparation step');
    }
  }
}
