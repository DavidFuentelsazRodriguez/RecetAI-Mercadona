import { RecipeSuggestion, RecipeGenerationParams } from '../../types/recipe.types';
import { Product, type ProductData } from '../../models/Product';
import {
  createGeminiChat,
  extractJsonResponse,
  validateNutritionalRequirements,
  handleGenerationError,
} from './recipeGeneration';
import { RecipeSuggestionSchema } from '../../types/recipe.schemas';
import { RecipeValidationError } from '../../errors/recipeErrors';
import { RecipePromptBuilder } from './recipePromptBuilder';
import { z } from 'zod';

export class RecipeService {
  private static readonly MAX_RETRIES = 2;
  private static readonly PRODUCT_FETCH_LIMIT = 100;

  /**
   * Generates a recipe based on the provided parameters.
   * The recipe is generated by a Gemini AI model that is given a prompt based on the parameters.
   * The prompt includes the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * The AI model is expected to generate a valid JSON with the RecipeSuggestion structure.
   * @param params The parameters for generating the recipe, including the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * @returns A promise that resolves to a valid RecipeSuggestion object.
   * @throws Error - If the AI model fails to generate a valid recipe, or if the generated recipe is missing a required field or does not include at least one ingredient and one step.
   */
  public static async generateRecipe(
    params: RecipeGenerationParams,
    retryCount: number = 0
  ): Promise<RecipeSuggestion> {
    if (retryCount > this.MAX_RETRIES) {
      console.error('Recipe generation failed after MAX_RETRIES');
      throw new RecipeValidationError('Failed to generate a valid recipe after several attempts.');
    }
    const ingredientThemes = params.preferences.ingredientThemes;
    const products = await this.fetchRelevantProducts(ingredientThemes);

    const originalPrompt = RecipePromptBuilder.buildPrompt(params, products, ingredientThemes);
    let rawApiResponseText: string | undefined;

    try {
      const chat = createGeminiChat();
      const result = await chat.sendMessage(originalPrompt);
      rawApiResponseText = result.response.text();

      const rawRecipeObject = extractJsonResponse(rawApiResponseText);
      const validatedRecipe = RecipeSuggestionSchema.parse(rawRecipeObject);

      validateNutritionalRequirements(validatedRecipe, products, params);

      return validatedRecipe;
    } catch (error) {
      if (error instanceof z.ZodError || error instanceof RecipeValidationError) {
        console.warn(`Attempt ${retryCount + 1} failed. Retrying with automatic correction...`);
        console.warn('Captured error:', error.message);

        const correctionPrompt = RecipePromptBuilder.buildCorrectionPrompt(
          error,
          rawApiResponseText,
          originalPrompt
        );

        return this.generateRecipeWithCorrection(
          params,
          products,
          correctionPrompt,
          retryCount + 1
        );
      }
      return handleGenerationError(error, rawApiResponseText);
    }
  }

  /**
   * Fetches products from the database that match the provided ingredient themes.
   * First, it fetches products that match the ingredient themes up to a limit of {@link PRODUCT_FETCH_LIMIT}.
   * If the limit is not reached, it fetches additional products that do not match the ingredient themes,
   * up to the remaining limit.
   * @param ingredientThemes An array of ingredient themes to match against product names.
   * @returns A promise that resolves to an array of product data objects.
   */
  private static async fetchRelevantProducts(ingredientThemes: string[]): Promise<ProductData[]> {
    try {
      const query = this.buildProductQuery(ingredientThemes);

      const themeProducts = await Product.find(query).limit(this.PRODUCT_FETCH_LIMIT).lean();

      const remainingLimit = this.PRODUCT_FETCH_LIMIT - themeProducts.length;

      if (remainingLimit <= 0) {
        return themeProducts;
      }

      const excludeIds = themeProducts.map(p => p._id);

      const additionalProducts = await Product.find({
        _id: { $nin: excludeIds },
      })
        .limit(remainingLimit)
        .lean();

      return [...themeProducts, ...additionalProducts];
    } catch (error) {
      console.error('Error fetching products:', error);
      return [];
    }
  }

  /**
   * Builds a MongoDB query to find products with names that match the provided ingredient themes.
   * If no themes are provided, an empty query object is returned.
   * @param themes An array of ingredient themes to match against product names.
   * @returns A MongoDB query object.
   */
  private static buildProductQuery(themes: string[]): Record<string, unknown> {
    const query: any = {};

    if (themes && themes.length > 0) {
      query.name = { $regex: themes.join('|'), $options: 'i' };
    }

    return query;
  }

  private static async generateRecipeWithCorrection(
    params: RecipeGenerationParams,
    products: ProductData[],
    correctionPrompt: string,
    retryCount: number
  ): Promise<RecipeSuggestion> {
    let rawApiResponseText: string | undefined;
    try {
      const chat = createGeminiChat();
      const result = await chat.sendMessage(correctionPrompt);
      rawApiResponseText = result.response.text();

      const rawRecipeObject = extractJsonResponse(rawApiResponseText);
      const validatedRecipe = RecipeSuggestionSchema.parse(rawRecipeObject);

      validateNutritionalRequirements(validatedRecipe, products, params);

      console.log(`Successful auto-correction on attempt ${retryCount}!`);
      return validatedRecipe;
    } catch (finalError) {
      return this.generateRecipe(params, retryCount);
    }
  }
}
