import { RecipeSuggestion, RecipeGenerationParams } from '../types/recipe.types';
import { Product, type ProductData } from '../models/Product';
import {
  createGeminiChat,
  extractJsonResponse,
  validateNutritionalRequirements,
  handleGenerationError,
} from './recipeGeneration';
import { RecipeSuggestionSchema } from '../types/recipe.schemas';
import { RecipeValidationError } from '../errors/recipeErrors';
import { z } from 'zod';

export class RecipeService {
  private static readonly PRODUCT_FETCH_LIMIT = 100;
  private static readonly DIET_DESCRIPTIONS: Record<string, string> = {
    vegan: 'Must be 100% plant-based, no animal products including honey, dairy, or eggs.',
    vegetarian: 'May include dairy and eggs but no meat, poultry, or fish.',
    keto: 'Must be very low in carbs (under 10g net carbs per serving).',
    'gluten-free': 'Must not contain wheat, barley, rye, or any gluten sources.',
    'lactose-free': 'Must not contain lactose or dairy products.',
    'high-protein': 'Must contain at least 25g of protein per serving.',
    'low-carb': 'Must contain less than 30g of net carbs per serving.',
    'high-fiber': 'Must contain at least 15g of fiber per serving.',
    omnivore: 'May include all food groups including meat, dairy, and plant-based ingredients.',
  };

  private static readonly STATIC_PROMPT_INSTRUCTIONS = `
### REQUIRED RESPONSE FORMAT (VALID JSON)
\`\`\`json
{
  "name": "string",
  "description": "string",
  "preparationTime": number,
  "servings": number,
  "difficulty": "easy" | "medium" | "hard",
  "ingredients": [
    {
      "name": "string",
      "quantity": number,
      "unit": "string"
    }
  ],
  "steps": ["string"],
  "nutritionalInfo": {
    "calories": number,
    "protein": number,
    "carbs": number,
    "fat": number,
    "sugar": number,
    "saturatedFat": number,
    "sodium": number,
    "fiber": number
  },
  "dietaryTags": ["string"]
}
\`\`\`

### STRICT RULES (MUST BE FOLLOWED)
1.  **VALID JSON**: The response MUST be a single JSON code block. Do not include any text before or after.
2.  **INGREDIENTS**:
    - You MUST base the recipe on ingredients from the "AVAILABLE INGREDIENT DATABASE".
    - You MUST satisfy all "MANDATORY INGREDIENT THEMES" by selecting at least one matching product from the list for each theme.
    - All quantities and units are required.
3.  **NUTRITION**:
    - The generated nutritional information (calories, protein, etc.) MUST be a realistic calculation based on the provided ingredients and their quantities.
    - It MUST meet the defined NUTRITIONAL GOALS.
4.  **DIFFICULTY**: Must be "easy", "medium", or "hard".
5.  **LANGUAGE**: Everything in English and in lowercase (except proper nouns if necessary).
6.  **UNITS**: All ingredient "unit" fields MUST be expressed in "g" (grams) or "kg" (kilograms). Do NOT use "units", "ml", "tbsp", "tsp", or any other measure.

### VALID EXAMPLE:
\`\`\`json
{
  "name": "quinoa salad with chicken breast",
  "description": "Fresh salad using quinoa and chicken breast from the list.",
  "preparationTime": 25,
  "servings": 2,
  "difficulty": "easy",
  "ingredients": [
    {"name": "quinoa (Hacendado)", "quantity": 100, "unit": "g"},
    {"name": "chicken breast (PolloFeliz)", "quantity": 150, "unit": "g"},
    {"name": "tomato", "quantity": 1, "unit": "unit"},
    {"name": "olive oil", "quantity": 1, "unit": "tablespoon"}
  ],
  "steps": ["Cook the quinoa", "Chop the vegetables", "Cook the chicken"],
  "nutritionalInfo": {
    "calories": 450,
    "protein": 30,
    "carbs": 40,
    "fat": 20,
    "fiber": 6
  },
  "dietaryTags": ["high protein", "gluten free"]
}
\`\`\`

### FINAL INSTRUCTIONS
Generate the recipe. Remember: your response must be ONLY the JSON block, and it must follow ALL the rules, especially using ingredients from the lists and meeting the nutritional goals.
`;

  /**
   * Generates a recipe based on the provided parameters.
   * The recipe is generated by a Gemini AI model that is given a prompt based on the parameters.
   * The prompt includes the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * The AI model is expected to generate a valid JSON with the RecipeSuggestion structure.
   * @param params The parameters for generating the recipe, including the nutritional goals, preferred ingredients, excluded ingredients, and instructions.
   * @returns A promise that resolves to a valid RecipeSuggestion object.
   * @throws Error - If the AI model fails to generate a valid recipe, or if the generated recipe is missing a required field or does not include at least one ingredient and one step.
   */
  public static async generateRecipe(params: RecipeGenerationParams): Promise<RecipeSuggestion> {
    const ingredientThemes = params.preferences.ingredientThemes;
    const products = await this.fetchRelevantProducts(ingredientThemes);

    const prompt = this.buildPrompt(params, products, ingredientThemes);
    let rawApiResponseText: string | undefined;

    try {
      const chat = createGeminiChat();

      const result = await chat.sendMessage(prompt);
      rawApiResponseText = result.response.text();

      const rawRecipeObject = extractJsonResponse(rawApiResponseText);
      const validatedRecipe = RecipeSuggestionSchema.parse(rawRecipeObject);

      validateNutritionalRequirements(validatedRecipe, products, params);

      return validatedRecipe;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const errorMessages = error.issues
          .map(e => `${e.path.join('.')} : ${e.message}`)
          .join('; ');
        throw new RecipeValidationError(
          `Invalid recipe structure received from AI: ${errorMessages}`
        );
      }
      return handleGenerationError(error, rawApiResponseText);
    }
  }

  
  /**
   * Fetches products from the database that match the provided ingredient themes.
   * First, it fetches products that match the ingredient themes up to a limit of {@link PRODUCT_FETCH_LIMIT}.
   * If the limit is not reached, it fetches additional products that do not match the ingredient themes,
   * up to the remaining limit.
   * @param ingredientThemes An array of ingredient themes to match against product names.
   * @returns A promise that resolves to an array of product data objects.
   */
  private static async fetchRelevantProducts(ingredientThemes: string[]): Promise<ProductData[]> {
    try {
      const query = this.buildProductQuery(ingredientThemes);

      const themeProducts = await Product
        .find(query)
        .limit(this.PRODUCT_FETCH_LIMIT)
        .lean();

      const remainingLimit = this.PRODUCT_FETCH_LIMIT - themeProducts.length;
      
      if (remainingLimit <= 0) {
        return themeProducts;
      }

      const excludeIds = themeProducts.map(p => p._id);

      const additionalProducts = await Product.find({
        _id: { $nin: excludeIds }, 
      })
        .limit(remainingLimit)
        .lean();

      return [...themeProducts, ...additionalProducts];
    } catch (error) {
      console.error('Error fetching products:', error);
      return [];
    }
  }

  /**
   * Builds a prompt for the AI model to generate a recipe.
   * The prompt includes the recipe generation instructions, dietary preferences, nutritional goals, mandatory ingredient themes, and available ingredients.
   * @param params The recipe generation parameters, including the dietary preferences and nutritional goals.
   * @param products An array of products from the database.
   * @param ingredientThemes An array of mandatory ingredient themes.
   * @returns A string containing the prompt for the AI model.
   */
  private static buildPrompt(
    params: RecipeGenerationParams,
    products: ProductData[],
    ingredientThemes: string[]
  ): string {
    const { preferences, nutritionalGoals } = params;

    const dietSection = this.buildDietaryPreferencesSection(preferences);
    const nutritionSection = this.buildNutritionalGoalsSection(nutritionalGoals);
    const themesSection = this.buildIngredientThemesSection(ingredientThemes);
    const ingredientsSection = this.buildAvailableIngredientsSection(products, ingredientThemes);

    const promptParts = [
      '## RECIPE GENERATION INSTRUCTIONS',
      'Your task is to generate a recipe in SPANISH that STRICTLY meets all the requirements.',
      dietSection,
      nutritionSection,
      themesSection,
      ingredientsSection,
      this.STATIC_PROMPT_INSTRUCTIONS,
    ];

    return promptParts.join('\n\n');
  }

  private static formatProducts(products: ProductData[]): string {
    if (products.length === 0) {
      return 'No specific products available. Use common ingredients.';
    }

    return products
      .map(
        p =>
          `- ${p.name}${p.brand ? ` (${p.brand})` : ''} | ` +
          `Calories: ${p.nutritionalInfo?.calories || 'N/A'} | ` +
          `Protein: ${p.nutritionalInfo?.protein || 'N/A'}g | ` +
          `Carbs: ${p.nutritionalInfo?.carbs || 'N/A'}g | ` +
          `Fat: ${p.nutritionalInfo?.fat || 'N/A'}g`
      )
      .join('\n');
  }

  private static buildDietaryPreferencesSection(
    preferences: RecipeGenerationParams['preferences']
  ): string {
    const dietInstruction =
      this.DIET_DESCRIPTIONS[preferences.diet] || 'No specific dietary restrictions.';

    return `
### DIETARY PREFERENCES
- **Diet type**: ${preferences.diet} (${dietInstruction})
- **Ingredients to avoid**: ${preferences.excludedIngredients.join(', ') || 'None'}
- **Cooking time**: ${preferences.cookingTime ? `${preferences.cookingTime} minutes` : 'Not specified'}
- **Difficulty**: ${preferences.difficulty || 'Any'}
`.trim();
  }

  private static buildNutritionalGoalsSection(
    nutritionalGoals: RecipeGenerationParams['nutritionalGoals']
  ): string {
    const { minCalories, maxCalories, minProtein, maxCarbs, maxFat } = nutritionalGoals;

    const lines = [
      minCalories ? `- Minimum calories: ${minCalories}` : null,
      maxCalories ? `- Maximum calories: ${maxCalories}` : null,
      minProtein ? `- Minimum protein: ${minProtein}g` : null,
      maxCarbs ? `- Maximum carbs: ${maxCarbs}g` : null,
      maxFat ? `- Maximum fat: ${maxFat}g` : null,
    ];

    const validLines = lines.filter(Boolean);

    const content =
      validLines.length > 0 ? validLines.join('\n') : 'No specific nutritional goals specified.';

    return `
### NUTRITIONAL GOALS (Per serving)
${content}
`.trim();
  }

  private static buildIngredientThemesSection(ingredientThemes: string[]): string {
    if (ingredientThemes.length === 0) {
      return '';
    }

    const themesList = ingredientThemes.map(theme => `- ${theme}`).join('\n');

    return `
### MANDATORY INGREDIENT THEMES
The recipe MUST include at least one product from the "AVAILABLE" list that matches each of the following themes:
${themesList}
`.trim();
  }

  private static buildAvailableIngredientsSection(
    products: any[],
    ingredientThemes: string[]
  ): string {
    const formattedProducts = this.formatProducts(products);
    const hasProducts = products.length > 0;
    const hasThemes = ingredientThemes.length > 0;

    const warning =
      !hasProducts && hasThemes
        ? '#### WARNING\nNo products found in the database. Generate a generic recipe using common ingredients that match the mandatory themes.\n'
        : '';

    return `
### AVAILABLE INGREDIENT DATABASE
Here are the ingredients from the database you can use to build the recipe:
${formattedProducts}

${warning}
`.trim();
  }

  /**
   * Builds a MongoDB query to find products with names that match the provided ingredient themes.
   * If no themes are provided, an empty query object is returned.
   * @param themes An array of ingredient themes to match against product names.
   * @returns A MongoDB query object.
   */
  private static buildProductQuery(themes: string[]): Record<string, unknown> {
    const query: any = {};

    if (themes && themes.length > 0) {
      query.name = { $regex: themes.join('|'), $options: 'i' };
    }

    return query;
  }
}
